In file included from src/action.c:7:
In file included from include/hikari/server.h:29:
In file included from include/hikari/layer_shell.h:4:
/usr/local/include/wlr/types/wlr_layer_shell_v1.h:52:52: error: field has incomplete type 'enum zwlr_layer_surface_v1_keyboard_interactivity'
        enum zwlr_layer_surface_v1_keyboard_interactivity keyboard_interactive;
                                                          ^
/usr/local/include/wlr/types/wlr_layer_shell_v1.h:52:7: note: forward declaration of 'enum zwlr_layer_surface_v1_keyboard_interactivity'
        enum zwlr_layer_surface_v1_keyboard_interactivity keyboard_interactive;
             ^
In file included from src/configuration.c:29:
In file included from include/hikari/server.h:8:
In file included from /usr/local/include/wlr/types/wlr_virtual_keyboard_v1.h:14:
In file included from /usr/local/include/wlr/interfaces/wlr_keyboard.h:13:
/usr/local/include/wlr/types/wlr_keyboard.h:113:10: error: conflicting types for 'wlr_keyboard_get_modifiers'
uint32_t wlr_keyboard_get_modifiers(struct wlr_keyboard *keyboard);
         ^
include/hikari/keyboard.h:61:24: note: previous implicit declaration is here
  uint32_t modifiers = wlr_keyboard_get_modifiers(keyboard->device->keyboard);
                       ^
In file included from src/configuration.c:32:
include/hikari/switch.h:14:25: error: field has incomplete type 'enum wlr_switch_state'
  enum wlr_switch_state state;
                        ^
include/hikari/switch.h:14:8: note: forward declaration of 'enum wlr_switch_state'
  enum wlr_switch_state state;
       ^
src/dnd_mode.c:25:23: error: use of undeclared identifier 'WLR_KEY_RELEASED'; did you mean 'WLR_BUTTON_RELEASED'?
  if (event->state == WLR_KEY_RELEASED) {
src/group_assign_mode.c:256:23: error: use of undeclared identifier 'WLR_KEY_PRESSED'
  if (event->state == WLR_KEY_PRESSED) {
src/input_grab_mode.c:53:23: error: use of undeclared identifier 'WLR_KEY_PRESSED'
  if (event->state == WLR_KEY_PRESSED) {
src/layout_select_mode.c:62:23: error: use of undeclared identifier 'WLR_KEY_PRESSED'
  if (event->state == WLR_KEY_PRESSED) {
src/lock_mode.c:180:23: error: use of undeclared identifier 'WLR_KEY_PRESSED'
  if (event->state == WLR_KEY_PRESSED) {
src/mark_assign_mode.c:164:23: error: use of undeclared identifier 'WLR_KEY_PRESSED'
  if (event->state == WLR_KEY_PRESSED) {
src/mark_select_mode.c:40:23: error: use of undeclared identifier 'WLR_KEY_PRESSED'
  if (event->state == WLR_KEY_PRESSED) {
src/move_mode.c:35:23: error: use of undeclared identifier 'WLR_KEY_RELEASED'; did you mean 'WLR_BUTTON_RELEASED'?
  if (event->state == WLR_KEY_RELEASED) {
src/normal_mode.c:322:23: error: use of undeclared identifier 'WLR_KEY_PRESSED'
  if (event->state == WLR_KEY_PRESSED) {
src/resize_mode.c:35:23: error: use of undeclared identifier 'WLR_KEY_RELEASED'; did you mean 'WLR_BUTTON_RELEASED'?
  if (event->state == WLR_KEY_RELEASED) {
src/sheet_assign_mode.c:169:23: error: use of undeclared identifier 'WLR_KEY_PRESSED'
  if (event->state == WLR_KEY_PRESSED) {
                      ^

src/server.c:756:61: error: too many arguments to function call, expected single argument 'display', have 2 arguments
  server->backend = wlr_backend_autocreate(server->display, NULL);
                    ~~~~~~~~~~~~~~~~~~~~~~                  ^~~~
/usr/include/sys/_null.h:34:14: note: expanded from macro 'NULL'
#define NULL    ((void *)0)
                ^~~~~~~~~~~
/usr/local/include/wlr/backend.h:35:21: note: 'wlr_backend_autocreate' declared here
struct wlr_backend *wlr_backend_autocreate(struct wl_display *display);
                    ^

00:00:00.167 [render/gles2/texture.c:162] Unsupported pixel format 0x0

--- include/hikari/keyboard.h.orig	2020-07-21 06:19:04 UTC
+++ include/hikari/keyboard.h
@@ -6,6 +6,7 @@
 #include <xkbcommon/xkbcommon.h>
 
 #include <wlr/types/wlr_input_device.h>
+#include <wlr/types/wlr_keyboard.h>
 
 #include <hikari/binding_group.h>
 #include <hikari/keyboard_config.h>
--- include/hikari/switch.h.orig	2020-07-21 06:19:04 UTC
+++ include/hikari/switch.h
@@ -2,6 +2,7 @@
 #define HIKARI_SWITCH_H
 
 #include <wlr/types/wlr_input_device.h>
+#include <wlr/types/wlr_switch.h>
 
 struct hikari_action;
 struct hikari_switch_config;
--- protocol/wlr-layer-shell-unstable-v1.xml.orig	2020-05-01 08:37:51 UTC
+++ protocol/wlr-layer-shell-unstable-v1.xml
@@ -25,7 +25,7 @@
     THIS SOFTWARE.
   </copyright>
 
-  <interface name="zwlr_layer_shell_v1" version="2">
+  <interface name="zwlr_layer_shell_v1" version="4">
     <description summary="create surfaces that are layers of the desktop">
       Clients can use this interface to assign the surface_layer role to
       wl_surfaces. Such surfaces are assigned to a "layer" of the output and
@@ -47,6 +47,12 @@
         or manipulate a buffer prior to the first layer_surface.configure call
         must also be treated as errors.
 
+        After creating a layer_surface object and setting it up, the client
+        must perform an initial commit without any buffer attached.
+        The compositor will reply with a layer_surface.configure event.
+        The client must acknowledge it and is then allowed to attach a buffer
+        to map the surface.
+
         You may pass NULL for output to allow the compositor to decide which
         output to use. Generally this will be the one that the user most
         recently interacted with.
@@ -82,9 +88,19 @@
       <entry name="top" value="2"/>
       <entry name="overlay" value="3"/>
     </enum>
+
+    <!-- Version 3 additions -->
+
+    <request name="destroy" type="destructor" since="3">
+      <description summary="destroy the layer_shell object">
+        This request indicates that the client will not use the layer_shell
+        object any more. Objects that have been created through this instance
+        are not affected.
+      </description>
+    </request>
   </interface>
 
-  <interface name="zwlr_layer_surface_v1" version="2">
+  <interface name="zwlr_layer_surface_v1" version="4">
     <description summary="layer metadata interface">
       An interface that may be implemented by a wl_surface, for surfaces that
       are designed to be rendered as a layer of a stacked desktop-like
@@ -93,6 +109,14 @@
       Layer surface state (layer, size, anchor, exclusive zone,
       margin, interactivity) is double-buffered, and will be applied at the
       time wl_surface.commit of the corresponding wl_surface is called.
+
+      Attaching a null buffer to a layer surface unmaps it.
+
+      Unmapping a layer_surface means that the surface cannot be shown by the
+      compositor until it is explicitly mapped again. The layer_surface
+      returns to the state it had right after layer_shell.get_layer_surface.
+      The client can re-map the surface by performing a commit without any
+      buffer attached, waiting for a configure event and handling it as usual.
     </description>
 
     <request name="set_size">
@@ -179,21 +203,85 @@
       <arg name="left" type="int"/>
     </request>
 
+    <enum name="keyboard_interactivity">
+      <description summary="types of keyboard interaction possible for a layer shell surface">
+        Types of keyboard interaction possible for layer shell surfaces. The
+        rationale for this is twofold: (1) some applications are not interested
+        in keyboard events and not allowing them to be focused can improve the
+        desktop experience; (2) some applications will want to take exclusive
+        keyboard focus.
+      </description>
+
+      <entry name="none" value="0">
+        <description summary="no keyboard focus is possible">
+          This value indicates that this surface is not interested in keyboard
+          events and the compositor should never assign it the keyboard focus.
+
+          This is the default value, set for newly created layer shell surfaces.
+
+          This is useful for e.g. desktop widgets that display information or
+          only have interaction with non-keyboard input devices.
+        </description>
+      </entry>
+      <entry name="exclusive" value="1">
+        <description summary="request exclusive keyboard focus">
+          Request exclusive keyboard focus if this surface is above the shell surface layer.
+
+          For the top and overlay layers, the seat will always give
+          exclusive keyboard focus to the top-most layer which has keyboard
+          interactivity set to exclusive. If this layer contains multiple
+          surfaces with keyboard interactivity set to exclusive, the compositor
+          determines the one receiving keyboard events in an implementation-
+          defined manner. In this case, no guarantee is made when this surface
+          will receive keyboard focus (if ever).
+
+          For the bottom and background layers, the compositor is allowed to use
+          normal focus semantics.
+
+          This setting is mainly intended for applications that need to ensure
+          they receive all keyboard events, such as a lock screen or a password
+          prompt.
+        </description>
+      </entry>
+      <entry name="on_demand" value="2" since="4">
+        <description summary="request regular keyboard focus semantics">
+          This requests the compositor to allow this surface to be focused and
+          unfocused by the user in an implementation-defined manner. The user
+          should be able to unfocus this surface even regardless of the layer
+          it is on.
+
+          Typically, the compositor will want to use its normal mechanism to
+          manage keyboard focus between layer shell surfaces with this setting
+          and regular toplevels on the desktop layer (e.g. click to focus).
+          Nevertheless, it is possible for a compositor to require a special
+          interaction to focus or unfocus layer shell surfaces (e.g. requiring
+          a click even if focus follows the mouse normally, or providing a
+          keybinding to switch focus between layers).
+
+          This setting is mainly intended for desktop shell components (e.g.
+          panels) that allow keyboard interaction. Using this option can allow
+          implementing a desktop shell that can be fully usable without the
+          mouse.
+        </description>
+      </entry>
+    </enum>
+
     <request name="set_keyboard_interactivity">
       <description summary="requests keyboard events">
-        Set to 1 to request that the seat send keyboard events to this layer
-        surface. For layers below the shell surface layer, the seat will use
-        normal focus semantics. For layers above the shell surface layers, the
-        seat will always give exclusive keyboard focus to the top-most layer
-        which has keyboard interactivity set to true.
+        Set how keyboard events are delivered to this surface. By default,
+        layer shell surfaces do not receive keyboard events; this request can
+        be used to change this.
 
+        This setting is inherited by child surfaces set by the get_popup
+        request.
+
         Layer surfaces receive pointer, touch, and tablet events normally. If
         you do not want to receive them, set the input region on your surface
         to an empty region.
 
-        Events is double-buffered, see wl_surface.commit.
+        Keyboard interactivity is double-buffered, see wl_surface.commit.
       </description>
-      <arg name="keyboard_interactivity" type="uint"/>
+      <arg name="keyboard_interactivity" type="uint" enum="keyboard_interactivity"/>
     </request>
 
     <request name="get_popup">
@@ -278,6 +366,7 @@
       <entry name="invalid_surface_state" value="0" summary="provided surface state is invalid"/>
       <entry name="invalid_size" value="1" summary="size is invalid"/>
       <entry name="invalid_anchor" value="2" summary="anchor bitfield is invalid"/>
+      <entry name="invalid_keyboard_interactivity" value="3" summary="keyboard interactivity is invalid"/>
     </enum>
 
     <enum name="anchor" bitfield="true">
@@ -295,7 +384,7 @@
 
         Layer is double-buffered, see wl_surface.commit.
       </description>
-      <arg name="layer" type="uint" enum="layer" summary="layer to move this surface to"/>
+      <arg name="layer" type="uint" enum="zwlr_layer_shell_v1.layer" summary="layer to move this surface to"/>
     </request>
   </interface>
 </protocol>
--- src/dnd_mode.c.orig	2020-09-08 08:20:26 UTC
+++ src/dnd_mode.c
@@ -22,7 +22,7 @@ static void
 key_handler(
     struct hikari_keyboard *keyboard, struct wlr_event_keyboard_key *event)
 {
-  if (event->state == WLR_KEY_RELEASED) {
+  if (event->state == WL_KEYBOARD_KEY_STATE_RELEASED) {
     hikari_server_enter_normal_mode(NULL);
   }
 }
--- src/group_assign_mode.c.orig	2020-09-08 08:20:26 UTC
+++ src/group_assign_mode.c
@@ -253,7 +253,7 @@ static void
 key_handler(
     struct hikari_keyboard *keyboard, struct wlr_event_keyboard_key *event)
 {
-  if (event->state == WLR_KEY_PRESSED) {
+  if (event->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
     uint32_t keycode = event->keycode + 8;
     hikari_keyboard_for_keysym(keyboard, keycode, handle_keysym);
   }
--- src/indicator_bar.c.orig	2020-09-08 08:20:26 UTC
+++ src/indicator_bar.c
@@ -4,6 +4,7 @@
 #include <pango/pangocairo.h>
 #include <string.h>
 
+#include <drm_fourcc.h>
 #include <wlr/backend.h>
 #include <wlr/render/wlr_renderer.h>
 #include <wlr/render/wlr_texture.h>
@@ -120,7 +121,7 @@ hikari_indicator_bar_update(struct hikari_indicator_ba
   int stride = cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, width);
 
   indicator_bar->texture = wlr_texture_from_pixels(
-      wlr_renderer, WL_SHM_FORMAT_ARGB8888, stride, width, height, data);
+      wlr_renderer, DRM_FORMAT_ARGB8888, stride, width, height, data);
 
   cairo_surface_destroy(surface);
   g_object_unref(layout);
--- src/input_grab_mode.c.orig	2020-10-22 15:14:16 UTC
+++ src/input_grab_mode.c
@@ -50,7 +50,7 @@ key_handler(
     struct hikari_keyboard *keyboard, struct wlr_event_keyboard_key *event)
 {
   struct hikari_workspace *workspace = hikari_server.workspace;
-  if (event->state == WLR_KEY_PRESSED) {
+  if (event->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
     uint32_t modifiers = hikari_server.keyboard_state.modifiers;
     struct hikari_binding_group *bindings = &keyboard->bindings[modifiers];
 
--- src/layout_select_mode.c.orig	2020-09-08 08:20:26 UTC
+++ src/layout_select_mode.c
@@ -59,7 +59,7 @@ static void
 key_handler(
     struct hikari_keyboard *keyboard, struct wlr_event_keyboard_key *event)
 {
-  if (event->state == WLR_KEY_PRESSED) {
+  if (event->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
     apply_layout(hikari_configuration, event, keyboard);
   }
 }
--- src/lock_indicator.c.orig	2020-07-21 06:19:04 UTC
+++ src/lock_indicator.c
@@ -1,5 +1,6 @@
 #include <hikari/lock_indicator.h>
 
+#include <drm_fourcc.h>
 #include <wlr/backend.h>
 #include <wlr/render/wlr_renderer.h>
 #include <wlr/types/wlr_matrix.h>
@@ -45,7 +46,7 @@ init_indicator_circle(float color[static 4])
   int stride = cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, size);
 
   texture = wlr_texture_from_pixels(
-      wlr_renderer, WL_SHM_FORMAT_ARGB8888, stride, size, size, data);
+      wlr_renderer, DRM_FORMAT_ARGB8888, stride, size, size, data);
 
   cairo_surface_destroy(surface);
   g_object_unref(layout);
--- src/lock_mode.c.orig	2020-09-08 08:20:26 UTC
+++ src/lock_mode.c
@@ -177,7 +177,7 @@ key_handler(
 {
   struct hikari_lock_mode *mode = get_mode();
 
-  if (event->state == WLR_KEY_PRESSED) {
+  if (event->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
     const xkb_keysym_t *syms;
     uint32_t keycode = event->keycode + 8;
     uint32_t codepoint;
--- src/mark_assign_mode.c.orig	2020-09-08 08:20:26 UTC
+++ src/mark_assign_mode.c
@@ -161,7 +161,7 @@ static void
 key_handler(
     struct hikari_keyboard *keyboard, struct wlr_event_keyboard_key *event)
 {
-  if (event->state == WLR_KEY_PRESSED) {
+  if (event->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
     assign_mark(event, keyboard);
   }
 }
--- src/mark_select_mode.c.orig	2020-09-08 08:20:26 UTC
+++ src/mark_select_mode.c
@@ -37,7 +37,7 @@ key_handler(
 {
   struct hikari_workspace *workspace = hikari_server.workspace;
 
-  if (event->state == WLR_KEY_PRESSED) {
+  if (event->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
     mark_select(workspace, event, keyboard);
   }
 }
--- src/move_mode.c.orig	2020-09-08 08:20:26 UTC
+++ src/move_mode.c
@@ -32,7 +32,7 @@ static void
 key_handler(
     struct hikari_keyboard *keyboard, struct wlr_event_keyboard_key *event)
 {
-  if (event->state == WLR_KEY_RELEASED) {
+  if (event->state == WL_KEYBOARD_KEY_STATE_RELEASED) {
     hikari_server_enter_normal_mode(NULL);
   }
 }
--- src/normal_mode.c.orig	2020-09-08 08:20:26 UTC
+++ src/normal_mode.c
@@ -319,7 +319,7 @@ key_handler(
     return;
   }
 
-  if (event->state == WLR_KEY_PRESSED) {
+  if (event->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
     uint32_t modifiers = hikari_server.keyboard_state.modifiers;
     struct hikari_binding_group *bindings = &keyboard->bindings[modifiers];
 
--- src/output.c.orig	2020-09-08 08:20:26 UTC
+++ src/output.c
@@ -1,5 +1,6 @@
 #include <hikari/output.h>
 
+#include <drm_fourcc.h>
 #include <wlr/backend.h>
 
 #include <hikari/memory.h>
@@ -86,7 +87,7 @@ hikari_output_load_background(struct hikari_output *ou
       wlr_backend_get_renderer(output->wlr_output->backend);
 
   output->background = wlr_texture_from_pixels(renderer,
-      WL_SHM_FORMAT_ARGB8888,
+      DRM_FORMAT_ARGB8888,
       stride,
       output_width,
       output_height,
--- src/resize_mode.c.orig	2020-09-08 08:20:26 UTC
+++ src/resize_mode.c
@@ -32,7 +32,7 @@ static void
 key_handler(
     struct hikari_keyboard *keyboard, struct wlr_event_keyboard_key *event)
 {
-  if (event->state == WLR_KEY_RELEASED) {
+  if (event->state == WL_KEYBOARD_KEY_STATE_RELEASED) {
     hikari_server_enter_normal_mode(NULL);
   }
 }
--- src/server.c.orig	2020-09-08 08:20:26 UTC
+++ src/server.c
@@ -753,7 +753,7 @@ hikari_server_prepare_privileged(void)
     goto done;
   }
 
-  server->backend = wlr_backend_autocreate(server->display, NULL);
+  server->backend = wlr_backend_autocreate(server->display);
   if (server->backend == NULL) {
     fprintf(stderr, "error: could not create backend\n");
     goto done;
--- src/sheet_assign_mode.c.orig	2020-09-08 08:20:26 UTC
+++ src/sheet_assign_mode.c
@@ -166,7 +166,7 @@ static void
 key_handler(
     struct hikari_keyboard *keyboard, struct wlr_event_keyboard_key *event)
 {
-  if (event->state == WLR_KEY_PRESSED) {
+  if (event->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
     uint32_t keycode = event->keycode + 8;
     hikari_keyboard_for_keysym(keyboard, keycode, handle_keysym);
   }
